#!/bin/bash
#
#    Copyright (C) MOXA Inc. All rights reserved.
#
#    This software is distributed under the terms of the
#    MOXA License.  See the file COPYING-MOXA for details.
#
#    /sbin/setinterface
#
#    Moxa set interface utility for DA-820C model
#
#    2018-09-20  Elvis CW Yao
#	 new release based on orginal setinterface
#

# FT4232 0x26, UART Port 0:4
UART_GPIO_2=(473 474 475 476)
UART_GPIO_3=(477 478 479 480)
UART_GPIO_4=(481 482 483 484)
UART_GPIO_5=(485 486 487 488)

# FT4232 0x27, UART Port 0:4
UART_GPIO_6=(457 458 459 460)
UART_GPIO_7=(461 462 463 464)
UART_GPIO_8=(465 466 467 468)
UART_GPIO_9=(469 470 471 472)

RS232_MODE=0
RS485_MODE=1
RS422_MODE=2
UNKNOWN_MODE=9
RS232_GPIO_MODE=(1 1 0 0)
RS485_GPIO_MODE=(0 0 0 1)
RS422_GPIO_MODE=(0 0 1 0)

RS232_MODE_STR="Now setting is RS232 mode"
RS485_MODE_STR="Now setting is RS485-2W mode"
RS422_MODE_STR="Now setting is RS422/RS485-4W mode"

UARTCONF="/etc/moxa-configs/setinterface.conf"

declare CUR_UART
declare CUR_MODE

check_root_user() {
	if [ x"$(whoami)" != x"root" ]; then
		echo "Permission denied."
		exit 1
	fi
}

usage() {
	echo -ne "Usage:  setinterface [OPTION]...\n"
	echo -ne " [device-node] [interface-no],\tset or get UART mode for sepcific port\n"
	echo -ne "\t\t\t\te.g. set mode: setinterface /dev/ttyM0 0\n"
	echo -ne "\t\t\t\te.g. get mode: setinterface /dev/ttyM0\n"
	echo -ne "\tdevice-node     - /dev/ttyMn, n = [0:${MAX_GPIO_PORT_NUM}]\n"
	echo -ne "\tinterface-no    - following:\n"
	echo -ne "\tnone - to view now setting\n"
	echo -ne "\t\t0 - set to RS232 interface\n"
	echo -ne "\t\t1 - set to RS485-2W interface\n"
	echo -ne "\t\t2 - set to RS422/RS485-4W interface\n"
	echo -ne " -h,\t show this help page\n"
	echo -ne " -s,\t save current UART mode to file\n"
	exit 0
}

save_status() {
	echo "Save current status to $UARTCONF ..."
	if [[ ! -f "$UARTCONF" ]]; then
		echo "setinterface config file $UARTCONF is not existed. Exit."
		exit 1
	fi

	index=0
	for index in `seq 0 $MAX_GPIO_PORT_NUM`
	do
		get_port_mode $index
		echo "Get port $index mode is $CUR_MODE"
		eval "sed -i -e '/#/!s/PORT${index}=[0-9]/PORT${index}=${CUR_MODE}/g' $UARTCONF"
	done

	exit 0
}

get_port_mode() {
	port=$1
	if [ $port -ge 0 ] && [ $port -le 1 ]; then
		io_board_uart_mode $(($port+1))
	elif [ $port -ge 2 ] && [ $port -le $MAX_GPIO_PORT_NUM ]; then
		exp_board_uart_mode $port
	else
		echo "Target device port $1 is invalid. Exit."
		exit 1
	fi
}

io_board_uart_mode() {
	port=$1
	mode=$2

	if [ -z "$mode" ]; then
		# get mode
		if [ x"1" == x"$(cat /sys/class/gpio/uart${port}_232/value)" ]; then
			CUR_MODE=$RS232_MODE
			echo $RS232_MODE_STR
		elif [ x"1" == x"$(cat /sys/class/gpio/uart${port}_485/value)" ]; then
			CUR_MODE=$RS485_MODE
			echo $RS485_MODE_STR
		elif [ x"1" == x"$(cat /sys/class/gpio/uart${port}_422/value)" ]; then
			CUR_MODE=$RS422_MODE
			echo $RS422_MODE_STR
		else
			echo "Cannot recognize the mode."
			CUR_MODE=$UNKNOWN_MODE
		fi
		return

	# set mode
	elif [ x"$mode" == x"$RS232_MODE" ]; then
		echo 1 > /sys/class/gpio/uart${port}_232/value 2>/dev/null
	elif [ x"$mode" == x"$RS485_MODE" ]; then
		echo 1 > /sys/class/gpio/uart${port}_485/value 2>/dev/null
	elif [ x"$mode" == x"$RS422_MODE" ]; then
		echo 1 > /sys/class/gpio/uart${port}_422/value 2>/dev/null
	else
		echo "Cannot recognize the mode."
		exit 1
	fi

	io_board_uart_mode $port
}

exp_board_uart_mode() {
	port=$1
	mode=$2
	gpio_init $port

	if [ -z "$mode" ]; then
		# get mode
		exp_board_get_uart_mode
		return

	# set mode
	elif [ x"$mode" == x"$RS232_MODE" ]; then
		exp_board_set_uart_mode $RS232_MODE
	elif [ x"$mode" == x"$RS485_MODE" ]; then
		exp_board_set_uart_mode $RS485_MODE
	elif [ x"$mode" == x"$RS422_MODE" ]; then
		exp_board_set_uart_mode $RS422_MODE
	else
		echo "Cannot recognize the mode."
		exit 1
	fi

	exp_board_uart_mode $port
}

exp_board_get_uart_mode() {
	local -a pin_array
	local -a cmp_result

	# fetch GPIO PIN status
	for ((i=0; i<${#CUR_UART[@]}; i++)); do
		pin_array[$i]=$(cat /sys/class/gpio/gpio${CUR_UART[$i]}/value)
	done

	# RS232 comparison
	cmp_result=$(diff_array pin_array[@] RS232_GPIO_MODE[@])
	if [ x"${cmp_result}" == x"0" ]; then
		echo $RS232_MODE_STR
		CUR_MODE=$RS232_MODE
		return
	fi

	# RS485-2W comparison
	cmp_result=$(diff_array pin_array[@] RS485_GPIO_MODE[@])
	if [ x"${cmp_result}" == x"0" ]; then
		echo $RS485_MODE_STR
		CUR_MODE=$RS485_MODE
		return
	fi

	# RS422/485-4W comparison
	cmp_result=$(diff_array pin_array[@] RS422_GPIO_MODE[@])
	if [ x"${cmp_result}" == x"0" ]; then
		echo $RS422_MODE_STR
		CUR_MODE=$RS422_MODE
		return
	fi

	echo "Cannot recognize current mode."
	CUR_MODE=$UNKNOWN_MODE
	exit 1
}

exp_board_set_uart_mode() {
	mode=$1
	case "$mode" in
		$RS422_MODE) # RS-422 mode
			for ((i=0; i<${#CUR_UART[@]}; i++)); do
				echo ${RS422_GPIO_MODE[$i]} > /sys/class/gpio/gpio${CUR_UART[$i]}/value
			done
		;;
		$RS485_MODE) # RS-485 mode
			for ((i=0; i<${#CUR_UART[@]}; i++)); do
				echo ${RS485_GPIO_MODE[$i]} > /sys/class/gpio/gpio${CUR_UART[$i]}/value
			done
		;;
		$RS232_MODE) # RS-232 mode
			for ((i=0; i<${#CUR_UART[@]}; i++)); do
				echo ${RS232_GPIO_MODE[$i]} > /sys/class/gpio/gpio${CUR_UART[$i]}/value
			done
		;;
		*)
			echo "Cannot recognize the mode."
		;;
	esac
}

# 
# This function will compare two arrays value in order to recognize current UART mode. 
#
diff_array() {
	declare -a arr1=("${!1}")
	declare -a arr2=("${!2}")
	[ ${#arr1[*]} != ${#arr2[*]} ] && { echo arrays different size; exit 1; }
	for ii in ${!arr1[*]}; do
		[ "${arr1[$ii]}" == "${arr2[$ii]}" ] || { echo different element $ii; echo 1 && return; }
	done
	echo 0
}

#
# Init GPIO PIN status, this function will be only executed ONCE
#
gpio_init_action() {
	# export the gpio if it's not existed
	uart_port=$1
	if [ ! -f /sys/class/gpio/gpio$uart_port/value ]; then
		echo $uart_port > /sys/class/gpio/export
	fi

	# set uart port as output
	direction=$(cat /sys/class/gpio/gpio$uart_port/direction)
	if [ x"$direction" == x"in" ]; then
		echo "out" > /sys/class/gpio/gpio$uart_port/direction
	fi
}

gpio_init() {
	# get current UART PIN from configuration file
	uart_port=$1
	CUR_UART=($(eval "echo \${"UART_GPIO_${uart_port}[@]"}"))
	
	if [ x"$CUR_UART" == x"" ]; then
		echo "The parameter is incorrect."		
		exit 2
	fi	
	
	for (( i=0; i<${#CUR_UART[@]}; i++ )); do
		gpio_init_action ${CUR_UART[$i]}
	done
}


main() {
	if [ x"$1" == x"-h" ]; then
		usage
	fi

	if [ x"$1" == x"-s" ]; then
		save_status
	fi

	check_root_user

	port=${1##*/dev/ttyM}
	mode=$2

	if [ ! -e $1 ]; then
		echo "Target device node $1 is not existed. Exit."
		exit 1
	fi

	if [ $port -ge 0 ] && [ $port -le 1 ]; then
		io_board_uart_mode $(($port+1)) $mode
	elif [ $port -ge 2 ] && [ $port -le $MAX_GPIO_PORT_NUM ]; then
		exp_board_uart_mode $port $mode
	else
		echo "Target device node $1 is invalid. Exit."
		exit 1
	fi
}

MAX_GPIO_PORT_NUM=$(ls /dev/ttyM* | wc -l)
let 'MAX_GPIO_PORT_NUM=MAX_GPIO_PORT_NUM - 1'

if [ $# -eq 0 ] || [ $# -gt 2 ]; then
	usage
fi

main $1 $2
